#!/bin/bash

set -e

if [ $# -lt 1 ]; then
    echo "Usage: $0 <public_key_file>" >&2
    echo "  public_key_file: Path to the public key file (PEM format)" >&2
    exit 1
fi

PUBLIC_KEY_FILE="$1"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLIENT_DIR="$(dirname "$SCRIPT_DIR")"
OUTPUT_HEADER="${CLIENT_DIR}/signing_key.h"

# Check if public key file exists
if [ ! -f "${PUBLIC_KEY_FILE}" ]; then
    echo "Error: Public key file not found at ${PUBLIC_KEY_FILE}" >&2
    exit 1
fi

# Generate header file
{
    echo "/*"
    echo " * Auto-generated signing public key header"
    echo " * Generated from: ${PUBLIC_KEY_FILE}"
    echo " * DO NOT EDIT - This file is automatically generated"
    echo " */"
    echo ""
    echo "#pragma once"
    echo ""
    echo "// Public key data in PEM format (as string literal)"
    echo "#define SIGNING_PUBLIC_KEY_DATA \\"

    # Convert PEM file to C string literal
    # Read file line by line and escape special characters
    # Note: read -r strips trailing newlines, so we add \n to each line
    while IFS= read -r line || [ -n "$line" ]; do
        # Escape backslashes and quotes, wrap in quotes
        escaped_line=$(echo "$line" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
        echo "    \"${escaped_line}\\n\" \\"
    done < "${PUBLIC_KEY_FILE}"

    # Add empty string to complete the macro (C will concatenate all strings)
    echo "    \"\""
    echo ""
    echo "// Public key data length (use sizeof(SIGNING_PUBLIC_KEY_DATA))"
    echo "#define SIGNING_PUBLIC_KEY_LEN (sizeof(SIGNING_PUBLIC_KEY_DATA))"
} > "${OUTPUT_HEADER}"

echo "Generated signing key header: ${OUTPUT_HEADER}"
